<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>2048 Cube 3D</title>
    
    <!-- Google AdSense Code -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7156019979499838" crossorigin="anonymous"></script>
    
    <!-- Three.js Engine -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    
    <style>
        /* Core Reset & Flex Layout to protect against Ad overlaps */
        html, body { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            background-color: #02040a; color: white; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Dedicated Ad Container at the top */
        #ad-container {
            width: 100%;
            z-index: 100;
            position: relative;
            background: transparent;
        }

        /* Game wrapper takes up all remaining vertical space */
        #game-wrapper {
            position: relative;
            flex: 1;
            width: 100%;
            overflow: hidden;
        }

        #canvas-container { position: absolute; inset: 0; z-index: 0; touch-action: none; }
        
        /* Game UI Wrapper */
        #game-ui { position: absolute; inset: 0; pointer-events: none; z-index: 10; }

        .ui { position: absolute; left: 0; right: 0; }
        .ui-top {
            top: 0;
            padding: max(20px, env(safe-area-inset-top)) 40px 20px;
            background: linear-gradient(to bottom, rgba(2, 6, 23, 0.9) 0%, rgba(2, 6, 23, 0) 100%);
            display: flex; justify-content: space-between; align-items: flex-start;
        }
        .ui-bottom {
            bottom: 0;
            padding: 20px 40px max(20px, env(safe-area-inset-bottom));
            background: linear-gradient(to top, rgba(2, 6, 23, 0.9) 0%, rgba(2, 6, 23, 0) 100%);
            display: flex; align-items: flex-end; justify-content: center;
        }

        .title-container { display: flex; flex-direction: column; text-align: left; }
        .title { font-size: 36px; font-weight: 900; font-style: italic; background: linear-gradient(135deg, #818cf8, #22d3ee); -webkit-background-clip: text; -webkit-text-fill-color: transparent; letter-spacing: -1px; line-height: 1; }
        .subtitle { font-size: 9px; opacity: 0.4; font-weight: 800; letter-spacing: 1.5px; white-space: nowrap; margin-top: 6px; text-transform: uppercase; }
        
        .right-panel { display: flex; flex-direction: column; align-items: flex-end; gap: 15px; }

        .score-group { display: flex; gap: 12px; }
        .score-box { background: rgba(15, 23, 42, 0.4); padding: 12px 20px; border-radius: 16px; text-align: center; min-width: 100px; border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(20px); }
        .label { font-size: 9px; text-transform: uppercase; opacity: 0.6; letter-spacing: 2px; font-weight: 900; margin-bottom: 2px; color: #94a3b8; }
        .value { font-size: 24px; font-weight: 900; font-variant-numeric: tabular-nums; color: white; }

        .btn-group { display: flex; gap: 10px; pointer-events: auto; align-items: center; }
        .btn { background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); color: white; padding: 12px; border-radius: 50%; cursor: pointer; font-weight: 800; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); backdrop-filter: blur(10px); display: flex; align-items: center; justify-content: center; width: 44px; height: 44px; }
        .btn:hover { background: rgba(255,255,255,0.15); transform: translateY(-2px); }
        .btn:active { transform: translateY(0); scale: 0.95; }
        .btn:disabled { opacity: 0.1; cursor: not-allowed; transform: none; box-shadow: none; }
        
        .flip-icon { transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1); }

        /* Floating Banner */
        .banner {
            position: absolute;
            top: 120px;
            left: 50%;
            width: 85%;
            max-width: 420px;
            transform: translate(-50%, -30px) scale(0.95);
            opacity: 0;
            visibility: hidden;
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid transparent;
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            padding: 18px 20px 18px 30px;
            border-radius: 40px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
            z-index: 9999;
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 20px 50px rgba(0,0,0,0.7);
            pointer-events: none; 
        }
        
        .banner.show { transform: translate(-50%, 0) scale(1); opacity: 1; visibility: visible; }
        .banner.interactive { pointer-events: auto; }
        
        .banner-text { display: flex; flex-direction: column; align-items: flex-start; }
        .banner-title { font-size: 18px; font-weight: 900; font-style: italic; letter-spacing: 1px; line-height: 1.2; }
        .banner-desc { font-size: 12px; opacity: 0.7; font-weight: 600; white-space: nowrap; margin-top: 4px; }
        
        .banner.stalemate { border-color: rgba(255, 60, 60, 0.5); }
        .banner.stalemate .banner-title { color: #ff3b30; }
        .banner.zenith { border-color: rgba(34, 211, 238, 0.5); }
        .banner.zenith .banner-title { color: #22d3ee; }

        .banner-btn {
            background: white; color: #020617; border: none; padding: 14px 28px;
            border-radius: 20px; font-weight: 800; font-size: 13px; cursor: pointer;
            transition: all 0.2s; text-transform: uppercase; letter-spacing: 0.5px;
        }
        .banner-btn:active { transform: scale(0.92); }

        /* Modals & Overlays */
        .modal-overlay {
            position: absolute; inset: 0; z-index: 10000;
            background: rgba(2, 4, 15, 0.75); 
            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            display: flex; align-items: center; justify-content: center;
            opacity: 0; visibility: hidden; transition: all 0.3s ease;
            pointer-events: auto;
        }
        .modal-overlay.show { opacity: 1; visibility: visible; }
        
        .modal-content {
            background: rgba(15, 23, 42, 0.95); border: 1px solid rgba(255,255,255,0.1);
            padding: 35px 30px; border-radius: 28px; text-align: center; max-width: 320px; width: 85%;
            box-shadow: 0 20px 50px rgba(0,0,0,0.6); 
            transform: scale(0.9); transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .modal-overlay.show .modal-content { transform: scale(1); }
        
        .modal-title { font-size: 22px; font-weight: 900; font-style: italic; color: white; margin-bottom: 12px; letter-spacing: 1px;}
        .modal-desc { font-size: 13px; color: #94a3b8; margin-bottom: 30px; line-height: 1.5; font-weight: 600;}
        .modal-actions { display: flex; gap: 12px; justify-content: center; }
        
        .modal-btn {
            flex: 1; padding: 15px 0; border-radius: 16px; font-weight: 800; font-size: 13px; cursor: pointer; border: none;
            transition: all 0.2s; text-transform: uppercase; letter-spacing: 0.5px;
        }
        .cancel-btn { background: rgba(255,255,255,0.1); color: white; }
        .cancel-btn:hover { background: rgba(255,255,255,0.2); }
        .confirm-btn { background: #ff3b30; color: white; }
        .confirm-btn:hover { background: #ff453a; }
        .modal-btn:active { transform: scale(0.95); }

        /* Objectives Modal Specific */
        #objectives-modal .modal-content {
            max-width: 450px; width: 90%; max-height: 85vh; padding: 30px 20px 20px;
            display: flex; flex-direction: column;
        }
        .objectives-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding: 0 10px; }
        .objectives-header .modal-title { margin-bottom: 0; }
        .close-btn { background: none; border: none; color: white; opacity: 0.6; cursor: pointer; font-size: 24px; padding: 0; }
        .close-btn:hover { opacity: 1; }
        
        .objectives-list {
            overflow-y: auto; display: flex; flex-direction: column; gap: 12px;
            padding-right: 10px; margin-bottom: 10px; flex: 1;
        }
        /* Custom Scrollbar for Objectives */
        .objectives-list::-webkit-scrollbar { width: 6px; }
        .objectives-list::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 4px; }
        .objectives-list::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 4px; }

        .obj-item {
            display: flex; align-items: center; gap: 15px; padding: 12px 15px;
            background: rgba(255,255,255,0.03); border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.05); text-align: left;
            opacity: 0.5; transition: all 0.3s;
        }
        .obj-item.unlocked {
            opacity: 1; border-color: rgba(34, 211, 238, 0.4);
            background: linear-gradient(135deg, rgba(34, 211, 238, 0.1) 0%, rgba(129, 140, 248, 0.1) 100%);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .obj-icon { font-size: 24px; filter: grayscale(100%); transition: all 0.3s; }
        .obj-item.unlocked .obj-icon { filter: grayscale(0%); transform: scale(1.1); }
        .obj-text { flex: 1; }
        .obj-title { font-size: 14px; font-weight: 800; color: white; margin-bottom: 4px; }
        .obj-item.unlocked .obj-title { color: #22d3ee; }
        .obj-desc { font-size: 11px; color: #94a3b8; font-weight: 600; line-height: 1.3;}

        /* Toast Notifications */
        #toast-container {
            position: fixed; top: 100px; left: 50%; transform: translateX(-50%);
            z-index: 10001; pointer-events: none; display: flex; flex-direction: column; gap: 10px;
        }
        .toast {
            background: rgba(15, 23, 42, 0.95); color: white; padding: 14px 24px;
            border-radius: 20px; font-weight: 700; font-size: 13px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 1px solid rgba(34, 211, 238, 0.4);
            display: flex; align-items: center; gap: 12px;
            animation: slideInDown 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            transition: opacity 0.4s ease, transform 0.4s ease;
        }
        .toast-icon { font-size: 18px; }
        @keyframes slideInDown {
            from { transform: translateY(-30px) scale(0.9); opacity: 0; }
            to { transform: translateY(0) scale(1); opacity: 1; }
        }

        /* Responsive Breakpoints */
        @media (max-width: 768px) {
            .ui-top { flex-direction: column; align-items: center; gap: 15px; padding: max(15px, env(safe-area-inset-top)) 15px 15px; text-align: center; }
            .right-panel { align-items: center; width: 100%; gap: 12px; }
            .title-container { text-align: center; }
            .title { font-size: 28px; }
            .score-box { min-width: 70px; padding: 10px 15px; }
            .value { font-size: 20px; }
            .ui-bottom { padding: 15px 15px max(15px, env(safe-area-inset-bottom)); }
            
            .banner { 
                top: min(18vh, 160px); flex-direction: column; gap: 18px; 
                padding: 24px; border-radius: 30px; text-align: center; 
            }
            .banner-text { align-items: center; }
            .banner-desc { white-space: normal; }
            .banner-btn { width: 100%; padding: 16px; font-size: 14px; }
        }
    </style>
</head>
<body>
    
    <!-- Ad Container -->
    <div id="ad-container"></div>
    
    <!-- Game Container (Dynamically resizes to avoid ad overlap) -->
    <div id="game-wrapper">
        <div id="canvas-container"></div>
        
        <!-- Main Game UI -->
        <div id="game-ui">
            <div class="ui ui-top">
                <div class="title-container">
                    <div class="title" id="game-title">2048 CUBE 3D</div>
                    <div class="subtitle">Click or Slide to merge identical boxes</div>
                </div>
                <div class="right-panel">
                    <div class="score-group">
                        <div class="score-box"><div class="label">Current</div><div class="value" id="score">0</div></div>
                        <div class="score-box"><div class="label">High Score</div><div class="value" id="best">0</div></div>
                    </div>
                    <div class="btn-group">
                        <!-- Trophy / Objectives Button -->
                        <button class="btn" onclick="openObjectives()" title="Objectives">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"></path>
                                <path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"></path>
                                <path d="M4 22h16"></path>
                                <path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"></path>
                                <path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"></path>
                                <path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"></path>
                            </svg>
                        </button>
                        <button id="undo-btn" class="btn" onclick="undoMove()" disabled title="Undo">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                        </button>
                        <button class="btn" onclick="promptReset()" title="Reset">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/><path d="M21 3v5h5"/></svg>
                        </button>
                    </div>
                </div>
            </div>

            <div class="banner" id="banner">
                <div class="banner-text">
                    <div class="banner-title" id="banner-title">STALEMATE</div>
                    <div class="banner-desc" id="banner-desc">No further synthesis possible.</div>
                </div>
                <button class="banner-btn" id="banner-btn" onclick="bannerAction()">RESTART</button>
            </div>

            <!-- Bottom Controls -->
            <div class="ui ui-bottom">
                <div class="btn-group">
                    <button id="move-left-btn" class="btn" onclick="directionalMove('left')" title="Slide Blocks Left (Relative to Camera)">
                        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>
                    </button>
                    <button id="move-down-btn" class="btn" onclick="directionalMove('down')" title="Push and Merge Blocks Towards the Bottom Floor">
                        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline></svg>
                    </button>
                    <button id="move-right-btn" class="btn" onclick="directionalMove('right')" title="Slide Blocks Right (Relative to Camera)">
                        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>
                    </button>
                    <button id="gravity-btn" class="btn" onclick="toggleGravity()" title="Invert Gravity">
                        <svg id="gravity-icon" class="flip-icon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M7 16V4M7 4L3 8M7 4L11 8M17 8v12M17 20l-4-4M17 20l4-4"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>

        <!-- Reset Confirmation Overlay -->
        <div id="reset-modal" class="modal-overlay">
            <div class="modal-content">
                <div class="modal-title">RESET GAME?</div>
                <div class="modal-desc">Are you sure you want to start over? Your current grid and score will be lost.</div>
                <div class="modal-actions">
                    <button class="modal-btn cancel-btn" onclick="hideResetModal()">CANCEL</button>
                    <button class="modal-btn confirm-btn" onclick="executeReset()">RESET</button>
                </div>
            </div>
        </div>

        <!-- Objectives / Achievements Overlay -->
        <div id="objectives-modal" class="modal-overlay">
            <div class="modal-content">
                <div class="objectives-header">
                    <div class="modal-title">OBJECTIVES</div>
                    <button class="close-btn" onclick="closeObjectives()">√ó</button>
                </div>
                <div class="objectives-list" id="objectives-list">
                    <!-- Injected dynamically via JS -->
                </div>
            </div>
        </div>
        
        <!-- Toast Notification Container -->
        <div id="toast-container"></div>
    </div>
    
    <script>
        // Game Constants
        const GRID_SIZE = 3; 
        const SPACING = 1.15;
        const COLORS = { 
            2: 0xf4f1ea, 4: 0x3498db, 8: 0xf39c12, 16: 0x2ecc71, 
            32: 0xe74c3c, 64: 0x9b59b6, 128: 0xf1c40f, 256: 0xff2d55, 
            512: 0xff3b30, 1024: 0x007aff, 2048: 0xffcc00
        };
        
        // State Variables
        let grid = [], score = 0, best = localStorage.getItem('cube2048_3x3_best') || 0;
        let history = [], moveCount = 0;
        let selected = null, gravityInverted = false; 
        
        // Three.js Objects
        let scene, camera, renderer, raycaster, mouse, cubeGroup;
        let blockMeshes = new Map(), textureCache = new Map();
        let rotX = 0.4, rotY = 0.6, isDrag = false, px = 0, py = 0, startX = 0, startY = 0;
        let isFlipping = false, flipProgress = 0, isModalOpen = false;
        let hasWon = false, currentBannerType = '';
        let bannerTimeout = null;

        const blockGeometry = new THREE.BoxGeometry(1, 1, 1);

        /* --- Objectives & Achievements Logic --- */
        let objectives = {
            obj_4: { title: "First Synthesis", desc: "Create a 4 tile.", unlocked: false, icon: "üî¢" },
            obj_16: { title: "Moving Up", desc: "Create a 16 tile.", unlocked: false, icon: "üöÄ" },
            obj_64: { title: "Cube Architect", desc: "Create a 64 tile.", unlocked: false, icon: "üèóÔ∏è" },
            obj_256: { title: "Halfway There", desc: "Create a 256 tile.", unlocked: false, icon: "üåì" },
            obj_512: { title: "The 512 Tile", desc: "Create a 512 tile.", unlocked: false, icon: "üî•" },
            obj_1024: { title: "1K Club", desc: "Create a 1024 tile.", unlocked: false, icon: "‚ú®" },
            obj_2048: { title: "Zenith", desc: "Create the 2048 tile.", unlocked: false, icon: "üëë" },
            obj_score_10: { title: "Combo Starter", desc: "Score 10+ points in one move.", unlocked: false, icon: "‚ö°" },
            obj_score_50: { title: "Chain Reaction", desc: "Score 50+ points in one move.", unlocked: false, icon: "üí•" },
            obj_score_100: { title: "Mega Merge", desc: "Score 100+ points in one move.", unlocked: false, icon: "ü§Ø" },
            obj_total_5000: { title: "Veteran", desc: "Reach 5,000 total score.", unlocked: false, icon: "üèÖ" },
            obj_gravity_5: { title: "Gravity Master", desc: "Use invert gravity 5 times in one game.", unlocked: false, icon: "üåÄ" }
        };
        let sessionStats = { gravityUses: 0 };

        function loadObjectives() {
            const saved = localStorage.getItem('cube2048_objectives');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    for (let key in parsed) {
                        if (objectives[key]) objectives[key].unlocked = parsed[key].unlocked;
                    }
                } catch(e) { console.error("Error loading objectives", e); }
            }
        }

        function saveObjectives() {
            localStorage.setItem('cube2048_objectives', JSON.stringify(objectives));
        }

        function showToast(title, icon) {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.innerHTML = `<span class="toast-icon">${icon}</span> Unlocked: ${title}`;
            container.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateY(-20px) scale(0.9)';
                setTimeout(() => toast.remove(), 400);
            }, 3000);
        }

        function checkObjectives(moveScore = 0, maxValueCreated = 0) {
            let unlockedAny = false;
            
            const checkAndUnlock = (id) => {
                if (!objectives[id].unlocked) {
                    objectives[id].unlocked = true;
                    showToast(objectives[id].title, objectives[id].icon);
                    unlockedAny = true;
                }
            };

            if (maxValueCreated >= 4) checkAndUnlock("obj_4");
            if (maxValueCreated >= 16) checkAndUnlock("obj_16");
            if (maxValueCreated >= 64) checkAndUnlock("obj_64");
            if (maxValueCreated >= 256) checkAndUnlock("obj_256");
            if (maxValueCreated >= 512) checkAndUnlock("obj_512");
            if (maxValueCreated >= 1024) checkAndUnlock("obj_1024");
            if (maxValueCreated >= 2048) checkAndUnlock("obj_2048");

            if (moveScore >= 10) checkAndUnlock("obj_score_10");
            if (moveScore >= 50) checkAndUnlock("obj_score_50");
            if (moveScore >= 100) checkAndUnlock("obj_score_100");

            if (score >= 5000) checkAndUnlock("obj_total_5000");
            if (sessionStats.gravityUses >= 5) checkAndUnlock("obj_gravity_5");

            if (unlockedAny) {
                saveObjectives();
                renderObjectivesList();
            }
        }

        function renderObjectivesList() {
            const list = document.getElementById('objectives-list');
            list.innerHTML = '';
            for (let key in objectives) {
                const obj = objectives[key];
                const div = document.createElement('div');
                div.className = `obj-item ${obj.unlocked ? 'unlocked' : ''}`;
                div.innerHTML = `
                    <div class="obj-icon">${obj.icon}</div>
                    <div class="obj-text">
                        <div class="obj-title">${obj.title}</div>
                        <div class="obj-desc">${obj.desc}</div>
                    </div>
                `;
                list.appendChild(div);
            }
        }

        function openObjectives() {
            if (isFlipping) return;
            isModalOpen = true;
            renderObjectivesList();
            document.getElementById('objectives-modal').classList.add('show');
        }

        function closeObjectives() {
            isModalOpen = false;
            document.getElementById('objectives-modal').classList.remove('show');
        }

        /* --- UI / Modal Functions --- */
        function promptReset() {
            if (isFlipping) return;
            isModalOpen = true;
            document.getElementById('reset-modal').classList.add('show');
        }

        function hideResetModal() {
            isModalOpen = false;
            document.getElementById('reset-modal').classList.remove('show');
        }

        function executeReset() {
            hideResetModal();
            resetGame();
        }

        /* --- Storage & Persistence Functions --- */
        function saveGameState() {
            const state = {
                grid: grid,
                score: score,
                moveCount: moveCount,
                gravityInverted: gravityInverted,
                hasWon: hasWon,
                history: history,
                sessionStats: sessionStats
            };
            localStorage.setItem('cube2048_3x3_state', JSON.stringify(state));
        }

        function loadGameState() {
            const saved = localStorage.getItem('cube2048_3x3_state');
            if (saved) {
                try {
                    const state = JSON.parse(saved);
                    grid = state.grid;
                    score = state.score;
                    moveCount = state.moveCount;
                    gravityInverted = state.gravityInverted || false;
                    hasWon = state.hasWon || false;
                    history = state.history || [];
                    sessionStats = state.sessionStats || { gravityUses: 0 };
                    
                    document.getElementById('gravity-icon').style.transform = gravityInverted ? 'rotate(180deg)' : 'rotate(0deg)';
                    document.getElementById('undo-btn').disabled = history.length === 0;
                    
                    sync();
                    checkGameState();
                    return true;
                } catch (e) {
                    console.error("Failed to load state", e);
                    return false;
                }
            }
            return false;
        }

        /* --- Banner Management Functions --- */
        function showBanner(type) {
            currentBannerType = type;
            const banner = document.getElementById('banner');
            const title = document.getElementById('banner-title');
            const desc = document.getElementById('banner-desc');
            const btn = document.getElementById('banner-btn');
            
            if(type === 'zenith') {
                title.innerText = 'ZENITH';
                desc.innerText = 'Ultimate cube synthesized.';
                btn.innerText = 'CONTINUE';
            } else {
                title.innerText = 'STALEMATE';
                desc.innerText = 'No further moves possible.';
                btn.innerText = 'RESTART';
            }

            banner.className = 'banner show ' + type;
            
            if(bannerTimeout) clearTimeout(bannerTimeout);
            bannerTimeout = setTimeout(() => {
                if (currentBannerType === type) {
                    banner.classList.add('interactive');
                }
            }, 1500); 
        }

        function hideBanner() {
            const banner = document.getElementById('banner');
            banner.className = 'banner';
            currentBannerType = '';
            if(bannerTimeout) clearTimeout(bannerTimeout);
        }

        function bannerAction() {
            if (currentBannerType === 'stalemate') resetGame(); 
            else if (currentBannerType === 'zenith') {
                hideBanner();
                checkGameState();
            }
        }

        function checkGameState() {
            let canMove = false;
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let z = 0; z < GRID_SIZE; z++) {
                        if (!grid[x][y][z]) {
                            canMove = true;
                            break;
                        }
                        const c = grid[x][y][z];
                        const ns = [[x+1,y,z],[x,y+1,z],[x,y,z+1]];
                        for (const [nx,ny,nz] of ns) {
                            if (nx < GRID_SIZE && ny < GRID_SIZE && nz < GRID_SIZE && grid[nx][ny][nz] && grid[nx][ny][nz].value === c.value) {
                                canMove = true;
                                break;
                            }
                        }
                        if (canMove) break;
                    }
                    if (canMove) break;
                }
                if (canMove) break;
            }
            
            if (!canMove && currentBannerType !== 'zenith') showBanner('stalemate');
            else if (canMove && currentBannerType === 'stalemate') hideBanner();
        }

        /* --- Procedural Textures Generation --- */
        function createTex(val) {
            if (textureCache.has(val)) return textureCache.get(val);
            const canvas = document.createElement('canvas'); 
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const color = '#' + (COLORS[val] || 0xedc22e).toString(16).padStart(6, '0');
            
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, 512, 512);
            
            const m = 30, r = 100;
            ctx.beginPath();
            ctx.moveTo(m + r, m);
            ctx.lineTo(512 - m - r, m);
            ctx.quadraticCurveTo(512 - m, m, 512 - m, m + r);
            ctx.lineTo(512 - m, 512 - m - r);
            ctx.quadraticCurveTo(512 - m, 512 - m, 512 - m - r, 512 - m);
            ctx.lineTo(m + r, 512 - m);
            ctx.quadraticCurveTo(m, 512 - m, m, 512 - m - r);
            ctx.lineTo(m, m + r);
            ctx.quadraticCurveTo(m, m, m + r, m);
            ctx.closePath();
            
            const grad = ctx.createLinearGradient(0, m, 0, 512 - m);
            grad.addColorStop(0, 'rgba(255, 255, 255, 0.15)');
            grad.addColorStop(1, 'rgba(0, 0, 0, 0.05)');
            
            ctx.fillStyle = color; ctx.fill();
            ctx.fillStyle = grad; ctx.fill();
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 12; ctx.stroke();

            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 20; ctx.shadowOffsetY = 12;
            
            ctx.fillStyle = val === 2 ? '#333333' : '#ffffff';
            let fontSize = val >= 1000 ? 140 : val >= 100 ? 180 : 220;
            ctx.font = `bold ${fontSize}px sans-serif`; 
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(val, 256, 256);
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.anisotropy = 16;
            tex.colorSpace = THREE.SRGBColorSpace;
            textureCache.set(val, tex);
            return tex;
        }

        function createNebulaTexture(colorHex) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const cx = 256, cy = 256, r = 256;
            const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
            
            const c = new THREE.Color(colorHex);
            gradient.addColorStop(0, `rgba(${Math.round(c.r*255)}, ${Math.round(c.g*255)}, ${Math.round(c.b*255)}, 0.6)`);
            gradient.addColorStop(0.4, `rgba(${Math.round(c.r*255)}, ${Math.round(c.g*255)}, ${Math.round(c.b*255)}, 0.2)`);
            gradient.addColorStop(1, `rgba(0, 0, 0, 0)`);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            return new THREE.CanvasTexture(canvas);
        }

        /* --- Initialization --- */
        function init() {
            const wrapper = document.getElementById('game-wrapper');
            scene = new THREE.Scene(); 
            scene.background = null; 
            
            camera = new THREE.PerspectiveCamera(35, wrapper.clientWidth / wrapper.clientHeight, 0.1, 2000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(wrapper.clientWidth, wrapper.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            cubeGroup = new THREE.Group();
            scene.add(cubeGroup);

            // Lighting setup
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            scene.add(new THREE.HemisphereLight(0x8080ff, 0x202040, 0.8)); 
            
            const dir = new THREE.DirectionalLight(0xffffff, 1.0);
            dir.position.set(5, 15, 8);
            dir.castShadow = true;
            dir.shadow.mapSize.width = 2048; dir.shadow.mapSize.height = 2048;
            dir.shadow.camera.left = -10; dir.shadow.camera.right = 10;
            dir.shadow.camera.top = 10; dir.shadow.camera.bottom = -10;
            dir.shadow.radius = 6;
            scene.add(dir);

            // Bright, Colorful Starfield
            const starGeo = new THREE.BufferGeometry();
            const starPos = [];
            const starColors = [];
            const colorObj = new THREE.Color();
            
            for(let i = 0; i < 8000; i++) {
                const u = Math.random(), v = Math.random();
                const theta = u * 2.0 * Math.PI, phi = Math.acos(2.0 * v - 1.0);
                const r = 800 * Math.cbrt(Math.random());
                
                if (r < 50) continue; 
                
                starPos.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
                
                const randHue = Math.random();
                if(randHue > 0.90) colorObj.setHSL(0.6, 0.8, 0.9); 
                else if(randHue > 0.80) colorObj.setHSL(0.1, 0.8, 0.9); 
                else colorObj.setHSL(0, 0, 1.0); 
                
                starColors.push(colorObj.r, colorObj.g, colorObj.b);
            }
            
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            starGeo.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
            
            const starMat = new THREE.PointsMaterial({ 
                size: 1.5, transparent: true, opacity: 1.0, vertexColors: true, sizeAttenuation: true
            });
            scene.add(new THREE.Points(starGeo, starMat));

            // Ambient Nebula Clouds
            const nebulaColors = [0x8a2be2, 0x4169e1, 0xff1493, 0x00ced1]; 
            const nebulaGroup = new THREE.Group();
            for(let i = 0; i < 20; i++) {
                const color = nebulaColors[Math.floor(Math.random() * nebulaColors.length)];
                const mat = new THREE.SpriteMaterial({ 
                    map: createNebulaTexture(color), blending: THREE.AdditiveBlending, transparent: true, opacity: 0.3 + Math.random() * 0.4
                });
                const sprite = new THREE.Sprite(mat);
                
                const theta = Math.random() * 2.0 * Math.PI;
                const phi = Math.acos(2.0 * Math.random() - 1.0);
                const r = 400 + Math.random() * 300; 
                sprite.position.set(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
                
                const scale = 200 + Math.random() * 400;
                sprite.scale.set(scale, scale, 1);
                nebulaGroup.add(sprite);
            }
            scene.add(nebulaGroup);

            // Interaction Event Listeners
            raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();

            const startDrag = (x, y) => { 
                if (isFlipping || isModalOpen) return;
                isDrag = true; px = x; py = y; startX = x; startY = y; 
            };
            const moveDrag = (x, y) => { 
                if (!isDrag) return; 
                rotY -= (x - px) * 0.005; rotX += (y - py) * 0.005; 
                rotX = Math.max(-1.4, Math.min(1.4, rotX)); 
                px = x; py = y; 
            };
            const endDrag = (clientX, clientY) => { 
                if (isDrag) {
                    if (Math.sqrt(Math.pow(clientX - startX, 2) + Math.pow(clientY - startY, 2)) <= 10) {
                        handleAction(clientX, clientY);
                    }
                    isDrag = false; 
                }
            };
            
            const handleAction = (clientX, clientY) => {
                if (isFlipping || isModalOpen) return;
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const hits = raycaster.intersectObjects(Array.from(blockMeshes.values()));
                if (hits.length > 0) click(hits[0].object.userData.pos);
            };

            renderer.domElement.addEventListener('pointerdown', (e) => startDrag(e.clientX, e.clientY));
            window.addEventListener('pointermove', (e) => moveDrag(e.clientX, e.clientY));
            window.addEventListener('pointerup', (e) => endDrag(e.clientX, e.clientY));
            window.addEventListener('pointercancel', () => isDrag = false);

            // Dynamically resize to wrapper
            window.addEventListener('resize', () => {
                const wrp = document.getElementById('game-wrapper');
                camera.aspect = wrp.clientWidth / wrp.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(wrp.clientWidth, wrp.clientHeight);
            });
            
            window.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undoMove(); }
                if (e.key === 'r') promptReset();
            });

            // Main Animation Render Loop
            function loop() {
                requestAnimationFrame(loop);
                
                const wrp = document.getElementById('game-wrapper');
                const aspect = wrp.clientWidth / wrp.clientHeight;
                const dynamicRadius = Math.max(13, 11 / aspect);

                camera.position.set(
                    dynamicRadius * Math.sin(rotY) * Math.cos(rotX), 
                    dynamicRadius * Math.sin(rotX), 
                    dynamicRadius * Math.cos(rotY) * Math.cos(rotX)
                );
                camera.lookAt(0, 0, 0);

                nebulaGroup.rotation.y += 0.0005;
                nebulaGroup.rotation.z += 0.0002;

                if (isFlipping) {
                    flipProgress += 0.035; 
                    if (flipProgress >= 1) flipProgress = 1;
                    
                    const ease = flipProgress < 0.5 ? 4 * flipProgress * flipProgress * flipProgress : 1 - Math.pow(-2 * flipProgress + 2, 3) / 2;
                    cubeGroup.rotation.z = ease * Math.PI; 
                    
                    if (flipProgress === 1) {
                        isFlipping = false;
                        cubeGroup.rotation.z = 0; 
                        
                        const newGrid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null)));
                        const off = (GRID_SIZE - 1) / 2;
                        
                        for (let x = 0; x < GRID_SIZE; x++) {
                            for (let y = 0; y < GRID_SIZE; y++) {
                                for (let z = 0; z < GRID_SIZE; z++) {
                                    if (grid[x][y][z]) {
                                        const newX = GRID_SIZE - 1 - x;
                                        const newY = GRID_SIZE - 1 - y;
                                        const newZ = z;
                                        newGrid[newX][newY][newZ] = grid[x][y][z];
                                        
                                        const m = blockMeshes.get(grid[x][y][z].id);
                                        if (m) {
                                            m.position.set((newX - off) * SPACING, (newY - off) * SPACING, (newZ - off) * SPACING);
                                            m.userData.target = m.position.clone();
                                        }
                                    }
                                }
                            }
                        }
                        grid = newGrid;
                        document.getElementById('gravity-btn').disabled = false;
                        
                        applyGravity();
                        sync();
                        checkGameState();
                        saveGameState();
                    }
                } else {
                    for (const m of blockMeshes.values()) {
                        if (m.userData.target) m.position.lerp(m.userData.target, 0.15);
                    }
                }
                
                renderer.render(scene, camera);
            }
            loop();
        }

        /* 
         * Camera-Relative Axis Mapper
         */
        function getScreenMappedDirection(screenDir) {
            const axes = [
                { axis: 'x', dir: 1, vec: new THREE.Vector3(1, 0, 0) },
                { axis: 'x', dir: -1, vec: new THREE.Vector3(-1, 0, 0) },
                { axis: 'z', dir: 1, vec: new THREE.Vector3(0, 0, 1) },
                { axis: 'z', dir: -1, vec: new THREE.Vector3(0, 0, -1) }
            ];

            let bestMatch = null;
            let maxScore = -Infinity;

            axes.forEach(a => {
                const p = a.vec.clone().project(camera);
                const score = (screenDir === 'right') ? p.x : -p.x;
                
                if (score > maxScore) {
                    maxScore = score;
                    bestMatch = a;
                }
            });

            return bestMatch;
        }

        function slideLine(line) {
            let newLine = [];
            let scoreGained = 0;
            let maxVal = 0;
            let filtered = line.filter(b => b !== null);
            let i = 0;
            while (i < filtered.length) {
                if (i + 1 < filtered.length && filtered[i].value === filtered[i+1].value) {
                    let val = filtered[i].value * 2;
                    scoreGained += val;
                    maxVal = Math.max(maxVal, val);
                    newLine.push({ id: filtered[i].id, value: val }); 
                    i += 2;
                } else {
                    newLine.push(filtered[i]);
                    i++;
                }
            }
            while (newLine.length < GRID_SIZE) newLine.push(null);
            return { newLine, scoreGained, maxVal };
        }

        function directionalMove(direction) {
            if (isFlipping || isModalOpen) return;
            saveHistory();
            
            let changed = false;
            let moveScore = 0;
            let moveMaxVal = 0;
            
            if (direction === 'down') {
                for (let x = 0; x < GRID_SIZE; x++) {
                    for (let z = 0; z < GRID_SIZE; z++) {
                        let line = [];
                        for (let y = 0; y < GRID_SIZE; y++) line.push(grid[x][y][z]);
                        
                        let res = slideLine(line);
                        let newLine = res.newLine;
                        moveScore += res.scoreGained;
                        moveMaxVal = Math.max(moveMaxVal, res.maxVal);
                        
                        for (let y = 0; y < GRID_SIZE; y++) {
                            if (grid[x][y][z] !== newLine[y]) changed = true;
                            grid[x][y][z] = newLine[y];
                        }
                        score += res.scoreGained;
                    }
                }
            } else if (direction === 'right' || direction === 'left') {
                const match = getScreenMappedDirection(direction);
                
                for (let y = 0; y < GRID_SIZE; y++) {
                    if (match.axis === 'x') {
                        for (let z = 0; z < GRID_SIZE; z++) {
                            let line = [];
                            for (let x = 0; x < GRID_SIZE; x++) line.push(grid[x][y][z]);
                            
                            if (match.dir === 1) line.reverse(); 
                            let res = slideLine(line);
                            let newLine = res.newLine;
                            if (match.dir === 1) newLine.reverse();
                            moveScore += res.scoreGained;
                            moveMaxVal = Math.max(moveMaxVal, res.maxVal);
                            
                            for (let x = 0; x < GRID_SIZE; x++) {
                                if (grid[x][y][z] !== newLine[x]) changed = true;
                                grid[x][y][z] = newLine[x];
                            }
                            score += res.scoreGained;
                        }
                    } else if (match.axis === 'z') {
                        for (let x = 0; x < GRID_SIZE; x++) {
                            let line = [];
                            for (let z = 0; z < GRID_SIZE; z++) line.push(grid[x][y][z]);
                            
                            if (match.dir === 1) line.reverse(); 
                            let res = slideLine(line);
                            let newLine = res.newLine;
                            if (match.dir === 1) newLine.reverse();
                            moveScore += res.scoreGained;
                            moveMaxVal = Math.max(moveMaxVal, res.maxVal);
                            
                            for (let z = 0; z < GRID_SIZE; z++) {
                                if (grid[x][y][z] !== newLine[z]) changed = true;
                                grid[x][y][z] = newLine[z];
                            }
                            score += res.scoreGained;
                        }
                    }
                }
            }
            
            if (changed) {
                applyGravity(); 
                moveCount++;
                spawnBlock(); // New block falls after every move
                
                if (score > best) { best = score; localStorage.setItem('cube2048_3x3_best', best); }
                sync();
                checkObjectives(moveScore, moveMaxVal);
                
                let zenithFound = false;
                for (let x = 0; x < GRID_SIZE; x++) {
                    for (let y = 0; y < GRID_SIZE; y++) {
                        for (let z = 0; z < GRID_SIZE; z++) {
                            if (grid[x][y][z] && grid[x][y][z].value === 2048) zenithFound = true;
                        }
                    }
                }
                
                if (zenithFound && !hasWon) {
                    hasWon = true;
                    showBanner('zenith');
                } else {
                    checkGameState();
                }
                saveGameState();
            } else {
                history.pop();
                if (history.length === 0) document.getElementById('undo-btn').disabled = true;
            }
        }

        function toggleGravity() {
            if (isFlipping || isModalOpen) return;
            saveHistory();
            isFlipping = true;
            flipProgress = 0;
            gravityInverted = !gravityInverted;
            document.getElementById('gravity-icon').style.transform = gravityInverted ? 'rotate(180deg)' : 'rotate(0deg)';
            document.getElementById('gravity-btn').disabled = true;
            
            sessionStats.gravityUses++;
            checkObjectives(0, 0);
        }

        function saveHistory() {
            const gridCopy = grid.map(layer => layer.map(row => row.map(cell => cell ? { ...cell } : null)));
            history.push({ 
                grid: gridCopy, 
                score: score, 
                moveCount: moveCount, 
                iconFlipped: gravityInverted,
                sessionStats: { ...sessionStats }
            });
            if (history.length > 30) history.shift();
            document.getElementById('undo-btn').disabled = false;
        }

        function undoMove() {
            if (history.length === 0 || isFlipping || isModalOpen) return;
            const last = history.pop();
            grid = last.grid; 
            score = last.score; 
            moveCount = last.moveCount; 
            gravityInverted = last.iconFlipped || false;
            sessionStats = last.sessionStats || { gravityUses: 0 };
            selected = null;
            
            document.getElementById('gravity-icon').style.transform = gravityInverted ? 'rotate(180deg)' : 'rotate(0deg)';
            
            if (history.length === 0) document.getElementById('undo-btn').disabled = true;
            sync();
            checkGameState();
            saveGameState();
        }

        function resetGame() {
            grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null)));
            for (let x = 0; x < GRID_SIZE; x++) for (let y = 0; y < GRID_SIZE; y++) for (let z = 0; z < GRID_SIZE; z++) {
                const r = Math.random(); 
                grid[x][y][z] = { id: Math.random().toString(36).substr(2, 9), value: r > 0.9 ? 8 : r > 0.7 ? 4 : 2 };
            }
            score = 0; moveCount = 0; selected = null; history = [];
            
            isFlipping = false;
            flipProgress = 0;
            if (cubeGroup) cubeGroup.rotation.z = 0;
            gravityInverted = false;
            hasWon = false;
            sessionStats = { gravityUses: 0 };
            
            document.getElementById('gravity-icon').style.transform = 'rotate(0deg)';
            document.getElementById('gravity-btn').disabled = false;
            document.getElementById('undo-btn').disabled = true;
            hideBanner();
            
            applyGravity(); 
            sync();
            saveGameState();
        }

        function sync() {
            const off = (GRID_SIZE - 1) / 2, ids = new Set();
            for (let x = 0; x < GRID_SIZE; x++) for (let y = 0; y < GRID_SIZE; y++) for (let z = 0; z < GRID_SIZE; z++) {
                const b = grid[x][y][z]; 
                if (!b) continue; 
                ids.add(b.id);
                let m = blockMeshes.get(b.id);
                
                if (!m) {
                    const materials = [];
                    const tex = createTex(b.value);
                    for (let i = 0; i < 6; i++) {
                        materials.push(new THREE.MeshStandardMaterial({ map: tex, metalness: 0.1, roughness: 0.2 }));
                    }
                    m = new THREE.Mesh(blockGeometry, materials);
                    m.castShadow = true; m.receiveShadow = true; 
                    cubeGroup.add(m); blockMeshes.set(b.id, m);
                    
                    const startY = b.isNew ? 12 : (y - off) * SPACING;
                    m.position.set((x - off) * SPACING, startY, (z - off) * SPACING);
                    if (b.isNew) delete b.isNew;
                }
                
                m.userData.target = new THREE.Vector3((x - off) * SPACING, (y - off) * SPACING, (z - off) * SPACING);
                m.userData.pos = [x, y, z];
                const sel = selected && selected[0] === x && selected[1] === y && selected[2] === z;
                
                m.scale.setScalar(sel ? 1.15 : 1);
                if (Array.isArray(m.material)) {
                    m.material.forEach((mat) => {
                        mat.emissive.setHex(sel ? 0x444444 : 0x000000);
                        if (m.userData.val !== b.value) {
                            mat.map = createTex(b.value);
                            mat.needsUpdate = true;
                        }
                    });
                }
                m.userData.val = b.value;
            }
            
            for (const [id, m] of blockMeshes.entries()) {
                if (!ids.has(id)) { cubeGroup.remove(m); blockMeshes.delete(id); }
            }
            document.getElementById('score').innerText = score;
            document.getElementById('best').innerText = best;
        }

        function applyGravity() {
            const ng = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null)));
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let z = 0; z < GRID_SIZE; z++) {
                    let ny = 0; 
                    for (let y = 0; y < GRID_SIZE; y++) {
                        if (grid[x][y][z]) {
                            ng[x][ny][z] = grid[x][y][z];
                            ny++;
                        }
                    }
                }
            }
            grid = ng;
        }

        function spawnBlock() {
            const validColumns = [];
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let z = 0; z < GRID_SIZE; z++) {
                    if (!grid[x][GRID_SIZE - 1][z]) { 
                        validColumns.push({ x, z });
                    }
                }
            }

            if (validColumns.length > 0) {
                const spot = validColumns[Math.floor(Math.random() * validColumns.length)];
                const r = Math.random();
                const val = r > 0.9 ? 8 : r > 0.7 ? 4 : 2;
                
                grid[spot.x][GRID_SIZE - 1][spot.z] = { 
                    id: Math.random().toString(36).substr(2, 9), 
                    value: val,
                    isNew: true
                };

                applyGravity();
            }
        }

        function click(pos) {
            if (isFlipping || isModalOpen) return;
            if (!selected) { selected = pos; }
            else if (selected[0] === pos[0] && selected[1] === pos[1] && selected[2] === pos[2]) { selected = null; }
            else {
                const b1 = grid[selected[0]][selected[1]][selected[2]], b2 = grid[pos[0]][pos[1]][pos[2]];
                const d = Math.abs(selected[0] - pos[0]) + Math.abs(selected[1] - pos[1]) + Math.abs(selected[2] - pos[2]);
                
                if (b1 && b2 && b1.value === b2.value && d === 1) { 
                    saveHistory();
                    const v = b1.value * 2; 
                    score += v; 
                    moveCount++;
                    if (score > best) { best = score; localStorage.setItem('cube2048_3x3_best', best); }
                    
                    grid[selected[0]][selected[1]][selected[2]] = null; 
                    grid[pos[0]][pos[1]][pos[2]] = { id: b2.id, value: v };
                    
                    applyGravity();
                    spawnBlock(); // New block falls after every successful manual merge
                    
                    selected = null;
                    
                    checkObjectives(v, v);

                    if (v === 2048 && !hasWon) {
                        hasWon = true;
                        showBanner('zenith');
                    } else {
                        checkGameState();
                    }
                } else { selected = pos; }
            }
            sync();
            saveGameState();
        }

        function initGame() {
            try {
                loadObjectives();
                init(); 
                document.getElementById('best').innerText = best;
                if (!loadGameState()) {
                    resetGame();
                }
            } catch (e) {
                console.error(e);
                alert("Critical System Failure: " + e.message);
            }
        }

        window.onload = initGame;
    </script>
</body>
</html>
